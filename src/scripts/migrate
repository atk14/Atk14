#!/usr/bin/env php
<?php
/**
 * Do pending migrations
 * 
 * For more help run
 *	$ ./scripts/migrations --help
 */

$arguments = getopt("hpf",array("help","preview","force"));
if(isset($arguments["h"]) || isset($arguments["help"])){
$script = $argv[0];
echo ltrim("
Do pending migrations
Load and process *.sql or *.php files from the migration folder (db/migrations/).

For displaying this help message run
 $ $script -h

To display migrations waiting for processing:
 $ $script -p

To process all pending migrations:
 $ $script

To process just specific migrations:
 $ $script 0010_migration.sql 0011_another_migration.sql

Force to process specific migration even when it was already processed:
 $ $script -f 0012_import_sample_data_migration.php

You can run migrate script in different environments:
 $ ATK14_ENV=development $script -p
 $ ATK14_ENV=production $script -p
 $ ATK14_ENV=test $script -p
                                                                                  
Note: table schema_migrations needs to be created in the database.
  CREATE TABLE schema_migrations(
    version VARCHAR(255) PRIMARY KEY
  );
You can create it by calling
 $ ./scripts/initialize_database
");
exit(0);
}

require_once(dirname(__FILE__)."/load.php");

$logger = Atk14Migration::GetLogger();

$previewing = isset($arguments["p"]) || isset($arguments["preview"]);

// read migrations from command line
// $ ./scripts/migrate -p 0009_adding_fileds_to_drafts.sql 0010_altering_constraint.sql
// -> array("0009_adding_fileds_to_drafts.sql","0010_altering_constraint")
$force_to_execute_migrations = array();
if(sizeof($argv)>1){
	$_argv = $argv;
	while($_argv){
		$_m = array_pop($_argv);
		if(preg_match('/^-/',$_m)){ break; }
		$force_to_execute_migrations[] = $_m;
	}
}

$forcing = (isset($arguments["f"]) || isset($arguments["force"])) && sizeof($force_to_execute_migrations);

// getting list of migration files
$migrations = array();
$dir = opendir($ATK14_GLOBAL->getMigrationsPath());
while($item = readdir($dir)){
	if(preg_match("/(.+)\\.(sql|inc|php)$/",$item,$matches)){
		$migrations[] = $item;
	}
}
closedir($dir);
asort($migrations);

// creating schema_migrations table when it doesn't exist
if(!Atk14Migration::SchemaMigrationsTableExists($dbmole)){
	Atk14Migration::CreateSchemaMigrationsTable($dbmole);
}

// getting list of done migrations
$already_done_migrations = $dbmole->selectIntoArray("SELECT version FROM schema_migrations ORDER BY version");

$counter = 0;
$ret = 0;
foreach($migrations as $m){
	if(in_array($m,$already_done_migrations) && !$forcing){ continue; }

	if($force_to_execute_migrations && !in_array($m,$force_to_execute_migrations)){ continue; }

	$counter++;

	if($previewing){
		$logger->info("$m");
		continue;
	}

	$logger->info("about to start migration $m"); $logger->flush();
	
	if(preg_match("/^[0-9]+_(.*)\\.(inc|php)$/",$m,$matches)){
		require_once($ATK14_GLOBAL->getMigrationsPath().$m);
		$class_name = preg_replace("/_/","",$matches[1]);
		$migr = new $class_name($m);
	}else{
		// an *.sql file
		$migr = new Atk14MigrationBySqlFile($m);
	}

	if(!$migr->migrateUp()){
		$ret = 1;
		break; // an error occured
	}

	$logger->info("migration $m has been successfully finished"); $logger->flush();
}

if($counter==0 && !$previewing){ $logger->info("there is nothing to migrate"); }

$logger->flush_all();
exit($ret);
